### 1. [Python装饰器](https://www.runoob.com/w3cnote/python-func-decorators.html)
    1. 装饰器在不修改现有函数代码的情况下，为函数增加额外的功能。
    2. 装饰器本质上是一个Python函数，它可以接受一个函数作为参数，并返回一个新的函数。
### 2. 装饰器工作原理
    1. 函数作为对象：通过接收一个函数（可以像其他对象一样被传递和操作）作为参数，可以在不修改原函数代码的情况下增强其功能。
    2. 嵌套函数：装饰器通常定义了一个内部函数（通常称为包装器或wrapper），这个内部函数会包裹原始函数，从而在原始函数被调用前后执行额外的代码。
    3. 返回包装器函数：装饰器最后返回这个包装器函数，替代了原始函数。因此，当原始函数名被调用时，实际上是在调用包装器函数。
### 3. 装饰器用途
    1. 记录日志：自动记录函数的调用细节。
    2. 性能测试：检测函数执行时间（用于计时的装饰器）。
    3. 访问控制：添加权限检查逻辑。
    4. 缓存：存储函数的返回值，避免重复计算。
### 4. 装饰器高级用法
#### 如何编写带参数的装饰器(参数化装饰器)?
    1. 参数化装饰器工作原理：在装饰器外面再包装一层函数，这样就可以接受参数了。
（参数化装饰器是装饰器工厂函数，接受参数并返回真正的装饰器。）
    2. 参数化装饰器的使用：在装饰器名字后面添加一对括号，括号中包含装饰器工厂函数的参数。
    3. 参数化装饰器基本上涉及至少两层嵌套函数，如果想使用@functools.wraps装饰器，需要把它放在最里层的函数上。
#### @functools.wraps装饰器
    1. 使用装饰器时，建议使用 functools.wraps，它会保留原始函数的元数据（如函数名和文档字符串）。
#### 叠放装饰器
    1. 装饰器的应用顺序从最近的开始向外应用。
### 5. 闭包
#### 1. 概念
    1. 闭包（Closure）是一种函数，它可以捕获并记住在其外部作用域定义的变量的值，即使那个外部作用域的执行已经结束。
    2. 闭包的关键特征是它允许函数访问那些不在函数内部定义的非全局变量。
#### 2. 闭包的构成条件
    1. 有一个嵌套的函数（一个函数内部定义了另一个函数）。
    2. 内部函数引用了外部函数的变量。
    3. 外部函数返回了内部函数。
