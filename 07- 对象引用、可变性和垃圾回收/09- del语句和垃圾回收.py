#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time: 2023/4/23 20:39
# @Author: 白云苍狗
# @File: 09- del语句和垃圾回收.py
# @Software: PyCharm
"""
1- 对象绝不会自行销毁，然而对象不可达时，可能会当作垃圾回收。
2- del语句删除引用，而不是对象。
    del不删除对象，但是执行del操作后可能会导致对象不可达，从而使得对象被删除。(当且仅当删除的变量保存的是对象的最后一个引用时)
    重新绑定也可能导致对象的引用数量归零，导致对象被销毁。
3- Python垃圾回收采用的是引用计数为主，标记-清除和分代回收为辅的策略。
    1. 在CPython中，垃圾回收的主要算法是引用计数。
        每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即被销毁：CPython在对象上调用__del__方法（如果定义了），然后释放分配给对象的内存。
    2. 标记清除
        首先假定所有的对象都是垃圾，然后假定在运行时的某个时刻，垃圾回收器会扫描所有的对象，并且标记所有被引用的对象。
    然后，垃圾回收器会回收所有未被标记的对象，并将其内存返回给操作系统。
    3. CPython2.0增加了分代回收，用于检测引用循环中涉及的对象组。
        如果一组对象之间全是相互引用，那么即使再出色的引用方式也会导致组中的对象不可达。

"""
import sys
import weakref

s1 = {1, 2, 3}
s2 = s1


def bye():
    print('...like tears in the rain.')


# 在s1引用的对象上注册bye回调。
# finalize持有{1, 2, 3}的弱引用。对象的弱引用不增加对象的引用计数。
# 因此，弱引用不阻碍目标对象被当作垃圾而回收。
# 弱引用在缓存应用中用得到，因为我们不希望由于存在对缓存的引用而导致缓存的对象无法被删除。
ender = weakref.finalize(s1, bye)
print(ender.alive)  # True
# del删除对象的引用s1
del s1
print(ender.alive)  # True
# 重新绑定最后一个引用s2，让{1, 2, 3}不可达。对象被销毁了，调用bye回调，ender.alive的值变成了False。
s2 = 'spam'  # ...like tears in the rain.
print(ender.alive)  # False

