1. 每个Python对象都有标识,类型和值.只有对象的值不时变化.
2. 如果两个变量指代的不可变变量具有相同的值(a == b为True),那么实际上他们指代的是副本还是同一个对象的别名基本没什么关系,因为不可变对象的值不会变.
3. 不可变容器是个例外.例如元组: 如果不可变容器存储的项是可变对象的引用,那么可变项的值发生变化后,不可变容器的值也会随之改变.
4. 变量保存的是引用,这点对Python编程有很多实质影响.
    1. 简单的赋值不创建副本.
    2. 对+=和*=所做的增量赋值来说
        1. 如果左边的变量绑定的是不可变对象,则创建新对象;
        2. 如果是可变对象,则就地修改.
    3. 为现有的变量赋予新值,不修改之前绑定的变量,这叫重新绑定.现在变量绑定了其他对象,如果变量是之前那个对象的最后一个引用,则对象被当作垃圾回收.
    4.
    函数的形参以别名的形式传递.这意味着函数可能会修改通过实参传入的可变对象.这一行为无法避免,除非在本地创建副本,或者使用不可变对象(
    例如: 传入元组,而不传入列表).
    5. 使用可变类型作为函数参数的默认值有危险,因为如果就地修改了参数,默认值也就变了,这会影响后续使用默认值的调用.
5. 垃圾回收
    1. 引用计数是Python中一种简单而有效的垃圾回收机制，用于自动管理对象的内存分配和释放。它跟踪每个对象的引用数量，并在引用计数减少到零时回收对象。
        1. 下面是引用计数机制的详细说明：
           当一个对象被创建时，它的引用计数被初始化为1。
           每当对象被引用时，其引用计数增加1。
           当对象的引用不再存在时，其引用计数减少1。
           引用计数可以通过sys.getrefcount(obj)函数来获取对象的当前引用计数。
        2. 垃圾回收：
           当对象的引用计数减少到零时，意味着该对象没有被任何引用，成为垃圾对象。
           垃圾回收器会定期扫描内存空间，查找引用计数为零的垃圾对象。
           一旦发现垃圾对象，垃圾回收器将释放其占用的内存空间，并将其从内存中删除。
        3. 循环引用的处理：
           引用计数机制可以处理简单的循环引用情况，即当两个对象相互引用时。
           Python的引用计数机制无法解决更复杂的循环引用问题，例如对象之间形成的循环引用链。
           为了处理这种情况，Python引入了其他的垃圾回收机制，如标记清除和分代回收。
        4. 引用计数机制的优点是简单高效，可以立即回收不再被引用的对象，并且不需要停止程序的执行。然而，引用计数机制并不能解决所有的内存管理问题，特别是循环引用的情况，因此需要其他的垃圾回收算法来处理这些情况。
        5. 总结来说，引用计数是Python中一种简单而高效的垃圾回收机制，通过跟踪对象的引用数量来管理内存分配和释放。它可以处理简单的引用关系并立即回收不再被引用的对象，但无法处理复杂的循环引用情况，需要其他垃圾回收机制的辅助。
    2. 标记清除（Mark and Sweep）是一种常用的垃圾回收算法，用于处理动态内存管理中的循环引用和不可达对象。它通过标记和回收两个阶段来执行垃圾回收操作。
        1. 标记阶段：从根节点开始遍历所有的引用对象，将所有被引用的对象标记为活动对象。
        2. 清除阶段：遍历整个堆内存，将未标记的对象清除。
        3. 标记清除算法的优点是可以处理循环引用和不可达对象，但缺点是执行效率不高，因为需要遍历所有的引用对象和堆内存。
        4. 总结起来，标记清除通过标记可达对象并清除不可达对象来回收内存空间。它是Python垃圾回收机制中的重要组成部分，用于自动管理动态内存分配和释放。
    3. 分代回收（Generational
       Collection）是一种常用的垃圾回收策略，用于根据对象的存活时间和代别来决定垃圾回收的频率和方式。Python中的分代回收主要基于两个观察结果：大部分对象在内存中存在的时间很短，而只有少部分对象长时间存在。
        1. 0代：存活时间短，垃圾回收频繁。
        2. 1代：存活时间长，垃圾回收频率低。
        3. 2代：存活时间更长，垃圾回收频率更低。
        4. 分代回收算法的优点是可以根据对象的存活时间采取不同的垃圾回收策略，提高垃圾回收的效率。但缺点是需要维护多个代的信息，增加了垃圾回收器的复杂度。
        5. 总结起来，分代回收通过将所有对象分为不同的代，然后根据代的特点采取不同的垃圾回收策略。它是Python垃圾回收机制中的重要组成部分，用于自动管理动态内存分配和释放。
6. Python引用计数
    1. 增加引用计数的条件
        1. 创建对象，例如，a = 3
        2. 将对象加入列表中，例如，my_list.append(a)
        3. 对象被引用，例如，b = a
        4. 作为参数传递给函数，例如，f(a)
    2. 减少引用计数的条件
        1. 引用被销毁，例如，del a
        2. 引用被重新绑定，例如，a = 24
        3. 引用在容器中被移除，例如，my_list.pop(a)
        4. 引用离开作用域，例如，f(a)，f函数执行完毕后，a不再存在